<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/ex3.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ex3.py" />
              <option name="originalContent" value="import numpy as np&#10;import matplotlib.pyplot as plt&#10;&#10;GAUSSIAN_VECTOR = [1, 4, 6, 4, 1]&#10;GAUSSIAN_KERNEL = np.array(GAUSSIAN_VECTOR, dtype=np.float64)&#10;REDUCE_KERNEL = GAUSSIAN_KERNEL / GAUSSIAN_KERNEL.sum()&#10;EXPAND_KERNEL = GAUSSIAN_KERNEL / (GAUSSIAN_KERNEL.sum() / 2.0)&#10;&#10;&#10;def _blur_single_channel(img, kernel):&#10;    blurred = np.zeros_like(img)&#10;    for i in range(img.shape[0]):&#10;        blurred[i, :] = np.convolve(img[i, :], kernel, mode='same')&#10;    for j in range(img.shape[1]):&#10;        blurred[:, j] = np.convolve(blurred[:, j], kernel, mode='same')&#10;    return blurred&#10;&#10;&#10;def blur(img, kernel):&#10;    img = img.astype(np.float64, copy=False)&#10;    if img.ndim == 2:&#10;        return _blur_single_channel(img, kernel)&#10;    blurred = np.zeros_like(img)&#10;    for c in range(img.shape[2]):&#10;        blurred[..., c] = _blur_single_channel(img[..., c], kernel)&#10;    return blurred&#10;&#10;&#10;def reduce(img):&#10;    smoothed = blur(img, REDUCE_KERNEL)&#10;    return smoothed[::2, ::2]&#10;&#10;&#10;def expand(img):&#10;    expanded_shape = (img.shape[0] * 2, img.shape[1] * 2) + (() if img.ndim == 2 else (img.shape[2],))&#10;    expanded_img = np.zeros(expanded_shape, dtype=np.float64)&#10;    expanded_img[::2, ::2, ...] = img&#10;    return blur(expanded_img, EXPAND_KERNEL)&#10;&#10;&#10;def gaussian_pyramid(img, num_of_levels):&#10;    &quot;&quot;&quot;Construct a Gaussian pyramid from the input image.&quot;&quot;&quot;&#10;    pyramid = [img]&#10;    current_img = img&#10;    for _ in range(1, num_of_levels):&#10;        if min(current_img.shape[:2]) &lt; 2:&#10;            break&#10;        reduced_img = reduce(current_img)&#10;        pyramid.append(reduced_img)&#10;        current_img = reduced_img&#10;    return pyramid&#10;&#10;&#10;def laplacian_pyramid(img, num_of_levels):&#10;    &quot;&quot;&quot;Construct a Laplacian pyramid from the input image.&quot;&quot;&quot;&#10;    gaussian_pyr = gaussian_pyramid(img, num_of_levels)&#10;    laplacian_pyr = []&#10;    for i in range(len(gaussian_pyr) - 1):&#10;        expanded = expand(gaussian_pyr[i + 1])&#10;        # Ensure the expanded image matches the size of the current Gaussian level&#10;        if expanded.shape != gaussian_pyr[i].shape:&#10;            target_height, target_width = gaussian_pyr[i].shape[:2]&#10;            expanded = expanded[:target_height, :target_width, ...]&#10;        laplacian_pyr.append(gaussian_pyr[i] - expanded)&#10;    laplacian_pyr.append(gaussian_pyr[-1])&#10;    return laplacian_pyr&#10;&#10;&#10;def load_image(img_path, as_gray=False):&#10;    img = plt.imread(img_path).astype(np.float64)&#10;    if img.max() &gt; 1.0:&#10;        img /= 255.0&#10;    if img.ndim == 3 and img.shape[2] == 4:&#10;        img = img[..., :3]&#10;    if as_gray and img.ndim == 3:&#10;        img = np.dot(img[..., :3], [0.299, 0.587, 0.114])&#10;    return img&#10;&#10;&#10;def max_pyramid_levels(shape):&#10;    h, w = shape[:2]&#10;    levels = 1&#10;    while min(h, w) &gt;= 2:&#10;        h = (h + 1) // 2&#10;        w = (w + 1) // 2&#10;        levels += 1&#10;    return levels&#10;&#10;&#10;def main():&#10;    &quot;&quot;&quot;&#10;    • Given two images A and B, and a binary mask M&#10;    • Construct Laplacian Pyramids La and Lb&#10;    • Construct a Gaussian Pyramid from mask M - Gm&#10;    • Create a third Laplacian Pyramid Lc where for each level k&#10;        (, ) = (, )*(, ) + (1 − (, ))*(, )&#10;    • Sum all levels Lc in to get the blended image&#10;    &quot;&quot;&quot;&#10;    # load images and mask&#10;    imgA_path = 'path_to_image_A'&#10;    imgB_path = 'path_to_image_B'&#10;    mask_path = 'path_to_mask_M'&#10;    imgA = load_image(imgA_path)&#10;    imgB = load_image(imgB_path)&#10;    mask = load_image(mask_path, as_gray=True)&#10;    mask = np.clip(mask, 0.0, 1.0)&#10;&#10;    # equalize sizes&#10;    min_shape = (min(imgA.shape[0], imgB.shape[0], mask.shape[0]),&#10;                 min(imgA.shape[1], imgB.shape[1], mask.shape[1]))&#10;    imgA = imgA[:min_shape[0], :min_shape[1], ...]&#10;    imgB = imgB[:min_shape[0], :min_shape[1], ...]&#10;    mask = mask[:min_shape[0], :min_shape[1]]&#10;&#10;    # determine number of levels&#10;    num_of_levels = min(max_pyramid_levels(imgA.shape),&#10;                        max_pyramid_levels(imgB.shape),&#10;                        max_pyramid_levels(mask.shape))&#10;&#10;    La = laplacian_pyramid(imgA, num_of_levels)&#10;    Lb = laplacian_pyramid(imgB, num_of_levels)&#10;    Gm = gaussian_pyramid(mask, num_of_levels)&#10;&#10;    # create blended Laplacian pyramid Lc&#10;    Lc = []&#10;    for k in range(num_levels):&#10;        Lc.append(Gm[k][..., None] * La[k] + (1 - Gm[k])[..., None] * Lb[k])&#10;&#10;    # reconstruct blended image from Lc&#10;    blended_img = Lc[-1]&#10;    for k in range(num_levels - 2, -1, -1):&#10;        blended_img = expand(blended_img)&#10;        # Ensure the expanded image matches the size of the current Lc level&#10;        if blended_img.shape != Lc[k].shape:&#10;            target_height, target_width = Lc[k].shape[:2]&#10;            blended_img = blended_img[:target_height, :target_width, ...]&#10;        blended_img += Lc[k]&#10;&#10;    blended_img = np.clip(blended_img, 0.0, 1.0)&#10;    plt.imsave('blended_result.png', blended_img)&#10;    return blended_img&#10;&#10;&#10;if __name__ == '__main__':&#10;    main()&#10;" />
              <option name="updatedContent" value="import numpy as np&#10;import matplotlib.pyplot as plt&#10;&#10;GAUSSIAN_VECTOR = [1, 4, 6, 4, 1]&#10;GAUSSIAN_KERNEL = np.array(GAUSSIAN_VECTOR, dtype=np.float64)&#10;REDUCE_KERNEL = GAUSSIAN_KERNEL / GAUSSIAN_KERNEL.sum()&#10;EXPAND_KERNEL = GAUSSIAN_KERNEL / (GAUSSIAN_KERNEL.sum() / 2.0)&#10;&#10;&#10;def _blur_single_channel(img, kernel):&#10;    blurred = np.zeros_like(img)&#10;    for i in range(img.shape[0]):&#10;        blurred[i, :] = np.convolve(img[i, :], kernel, mode='same')&#10;    for j in range(img.shape[1]):&#10;        blurred[:, j] = np.convolve(blurred[:, j], kernel, mode='same')&#10;    return blurred&#10;&#10;&#10;def blur(img, kernel):&#10;    img = img.astype(np.float64, copy=False)&#10;    if img.ndim == 2:&#10;        return _blur_single_channel(img, kernel)&#10;    blurred = np.zeros_like(img)&#10;    for c in range(img.shape[2]):&#10;        blurred[..., c] = _blur_single_channel(img[..., c], kernel)&#10;    return blurred&#10;&#10;&#10;def reduce(img):&#10;    smoothed = blur(img, REDUCE_KERNEL)&#10;    return smoothed[::2, ::2]&#10;&#10;&#10;def expand(img):&#10;    expanded_shape = (img.shape[0] * 2, img.shape[1] * 2) + (() if img.ndim == 2 else (img.shape[2],))&#10;    expanded_img = np.zeros(expanded_shape, dtype=np.float64)&#10;    expanded_img[::2, ::2, ...] = img&#10;    return blur(expanded_img, EXPAND_KERNEL)&#10;&#10;&#10;def gaussian_pyramid(img, num_of_levels):&#10;    &quot;&quot;&quot;Construct a Gaussian pyramid from the input image.&quot;&quot;&quot;&#10;    pyramid = [img]&#10;    current_img = img&#10;    for _ in range(1, num_of_levels):&#10;        if min(current_img.shape[:2]) &lt; 2:&#10;            break&#10;        reduced_img = reduce(current_img)&#10;        pyramid.append(reduced_img)&#10;        current_img = reduced_img&#10;    return pyramid&#10;&#10;&#10;def laplacian_pyramid(img, num_of_levels):&#10;    &quot;&quot;&quot;Construct a Laplacian pyramid from the input image.&quot;&quot;&quot;&#10;    gaussian_pyr = gaussian_pyramid(img, num_of_levels)&#10;    laplacian_pyr = []&#10;    for i in range(len(gaussian_pyr) - 1):&#10;        expanded = expand(gaussian_pyr[i + 1])&#10;        # Ensure the expanded image matches the size of the current Gaussian level&#10;        if expanded.shape != gaussian_pyr[i].shape:&#10;            target_height, target_width = gaussian_pyr[i].shape[:2]&#10;            expanded = expanded[:target_height, :target_width, ...]&#10;        laplacian_pyr.append(gaussian_pyr[i] - expanded)&#10;    laplacian_pyr.append(gaussian_pyr[-1])&#10;    return laplacian_pyr&#10;&#10;&#10;def load_image(img_path, as_gray=False):&#10;    img = plt.imread(img_path).astype(np.float64)&#10;    if img.max() &gt; 1.0:&#10;        img /= 255.0&#10;    if img.ndim == 3 and img.shape[2] == 4:&#10;        img = img[..., :3]&#10;    if as_gray and img.ndim == 3:&#10;        img = np.dot(img[..., :3], [0.299, 0.587, 0.114])&#10;    return img&#10;&#10;&#10;def max_pyramid_levels(shape):&#10;    h, w = shape[:2]&#10;    levels = 1&#10;    while min(h, w) &gt;= 2:&#10;        h = (h + 1) // 2&#10;        w = (w + 1) // 2&#10;        levels += 1&#10;    return levels&#10;&#10;&#10;def main():&#10;    &quot;&quot;&quot;&#10;    • Given two images A and B, and a binary mask M&#10;    • Construct Laplacian Pyramids La and Lb&#10;    • Construct a Gaussian Pyramid from mask M - Gm&#10;    • Create a third Laplacian Pyramid Lc where for each level k&#10;        (, ) = (, )*(, ) + (1 − (, ))*(, )&#10;    • Sum all levels Lc in to get the blended image&#10;    &quot;&quot;&quot;&#10;    # load images and mask&#10;    imgA_path = 'path_to_image_A'&#10;    imgB_path = 'path_to_image_B'&#10;    mask_path = 'path_to_mask_M'&#10;    imgA = load_image(imgA_path)&#10;    imgB = load_image(imgB_path)&#10;    mask = load_image(mask_path, as_gray=True)&#10;    mask = np.clip(mask, 0.0, 1.0)&#10;&#10;    # equalize sizes&#10;    min_shape = (min(imgA.shape[0], imgB.shape[0], mask.shape[0]),&#10;                 min(imgA.shape[1], imgB.shape[1], mask.shape[1]))&#10;    imgA = imgA[:min_shape[0], :min_shape[1], ...]&#10;    imgB = imgB[:min_shape[0], :min_shape[1], ...]&#10;    mask = mask[:min_shape[0], :min_shape[1]]&#10;&#10;    # determine number of levels&#10;    num_of_levels = min(max_pyramid_levels(imgA.shape),&#10;                        max_pyramid_levels(imgB.shape),&#10;                        max_pyramid_levels(mask.shape))&#10;&#10;    La = laplacian_pyramid(imgA, num_of_levels)&#10;    Lb = laplacian_pyramid(imgB, num_of_levels)&#10;    Gm = gaussian_pyramid(mask, num_of_levels)&#10;&#10;    # create blended Laplacian pyramid Lc&#10;    Lc = []&#10;    for k in range(num_levels):&#10;        Lc.append(Gm[k][..., None] * La[k] + (1 - Gm[k])[..., None] * Lb[k])&#10;&#10;    # reconstruct blended image from Lc&#10;    blended_img = Lc[-1]&#10;    for k in range(num_levels - 2, -1, -1):&#10;        blended_img = expand(blended_img)&#10;        # Ensure the expanded image matches the size of the current Lc level&#10;        if blended_img.shape != Lc[k].shape:&#10;            target_height, target_width = Lc[k].shape[:2]&#10;            blended_img = blended_img[:target_height, :target_width, ...]&#10;        blended_img += Lc[k]&#10;&#10;    blended_img = np.clip(blended_img, 0.0, 1.0)&#10;    plt.imsave('blended_result.png', blended_img)&#10;    return blended_img&#10;&#10;&#10;if __name__ == '__main__':&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>